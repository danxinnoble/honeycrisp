class Ring(object):

  # Defines parameters for the ring Z/pZ/<X^n + 1>
  # i.e. A ring of polynomials where coefficients are
  #   in Z/pZ, and where polynomial multiplication is 
  #   reduced over X^n+1
  # p is the prime modulus natively used by SCALE-MAMBA
  # Require also that p = 1 (mod 2n)
  # n = 2^nBitsN
  # w is a 2nth primitive root of unity
  # All are public (non-secret) values
  def __init__(self, nBitsN, w):
    self.n = 1 << nBitsN
    self.nBitsN = nBitsN
    self.w = w
    return

  # Return a random element in [0, p)
  def randElem(self):
    return sint.get_random_triple()[0]

  # Return a random cint in [0, p)
  def randElemClear(self):
    return self.randElem().reveal()

  # Returns 0 or 1 each with chance 0.5
  def randBit(self):
    b = sint.get_random_int(1)
    return b

  # Selects r from (X~B(2n, 0.5) - n) mod p
  # i.e. should be centered at 0
  def modBinom(self, n):
    r = sint(0)
    for i in range(0, 2*n):
      r = r + self.randBit()
    return r - n


  # RING OPERATIONS
  # These operations are performed in a ring Z/pZ/<x^n + 1>
  # Here p is the modulus used by SCALE-MAMBA
  # It is assumed that n = len(a) = len(b).

  # Ring addition (i.e. pointwise vector addition mod p)
  def ringAdd(self, a, b):
    res = []
    for i in range(0, len(a)):
      res.append(a[i] + b[i])
    return res

  # Ring subtraction (i.e. pointwise vector subtraction mod p)
  def ringSub(self, a, b):
    res = []
    for i in range(0, len(a)):
      res.append(a[i] - b[i])
    return res

  # Ring multiplication (i.e. convolution)
  # Polynomials are represented with lowest powers first
  #   e.g. (1 + 2x + 3x^2) is represented as [1, 2, 3]
  # Reduce polynomial modulo x^(len(a)) + 1
  def ringMul(self, a, b):
    conv = []
    for i in range(len(a) + len(b)):
      conv.append(sint(0))
    for i in range(0, len(a)):
      for j in range(0, len(b)):
        conv[i+j] = conv[i+j] + ( a[i] * b[j] )

    res = []
    for i in range(len(a)-1):
      res.append(conv[i] - conv[i+len(a)])
    res.append(conv[len(a) - 1])
    return res

  # Fast Ring multiplication
  # From Bernstein, Daniel. "Fast multiplication and its applications." 
  # See https://cr.yp.to/papers.html#multapps
  # a, b: operands (elements of Z/pZ/<X^n + 1>
  # n : length of polynomials
  # For this to work, need len(a) = len(b) = n = 2^nBitsN
  # Note that this uses operations NATIVELY in the SCALE-MAMBA field.
  # Let p be the modulus used by SCALE-MAMBA
  # We require: p = 1 (mod 2n), w^n = -1 (mod p)
  def ringMulFast(self, a, b):
    n = self.n
    nBitsN = self.nBitsN
    nProd = self.ringMulFastRec(a, b, n, nBitsN-1, n/2)  
    res = []
    for i in range(0, n):
      res.append(nProd[i] / n)
    return res 
 
  # Return a * b
  # n = 2^nBitsN = len(a) = len(b)
  def ringMulFastRec(self, a, b, n, nBitsN, wExp): 
    res = []
    if n == 1:
      res.append(a[0] * b[0])
      return res
    
    c = self.w ** (wExp)
 
    aSplitAdd = []
    aSplitSub = []
    for i in range(0, n/2):
      t = a[i + n/2] * c
      aSplitAdd.append(a[i] + t)
      aSplitSub.append(a[i] - t)

    bSplitAdd = []
    bSplitSub = []
    for i in range(0, n/2):
      t = b[i + n/2] * c
      bSplitAdd.append(b[i] + t)
      bSplitSub.append(b[i] - t)

    resAdd = self.ringMulFastRec(aSplitAdd, bSplitAdd, n/2, nBitsN - 1, wExp/2)
    resSub = self.ringMulFastRec(aSplitSub, bSplitSub, n/2, nBitsN - 1, wExp/2 + self.n/2)
  
    for i in range(0, n/2):
      t = resAdd[i] + resSub[i]
      res.append(t)
    for i in range(0, n/2):
      t = resAdd[i] - resSub[i]
      res.append(t/c)
     
    return res

  # Random ring element
  # Returns a vector of length n 
  # Each item is chosen uniformally at random from [0, p)
  def ringRand(self):
    n = self.n
    res = []
    for i in range(0, n):
      res.append(self.randElem())
    return res

  def ringRandClear(self):
    n = self.n
    res = []
    for i in range(0, n):
      res.append(self.randElemClear())
    return res

  # Returns a vector of length n 
  # Each item is chosen independently at random from (B(2N, 0.5) - N) mod p
  def ringBinom(self, N):
    n = self.n
    res = []
    for i in range(0, n):
      res.append(self.modBinom(N))
    return res

  def ringRevealPrettyPrint(self, a):
    print_ln("[ ")
    for i in range(0, len(a)):
      print_ln("%s ", a[i].reveal())
    print_ln("]")
    return

  def reveal(self, a):
    n = self.n
    aClear = []
    for i in range(0, n):
      aClear.append(a[i].reveal())
    return aClear

  # a is a ring element
  def ringRevealToParty(self, a, partyNum):
    for i in range(0, len(a)):
      a[i].reveal_to(partyNum)


  def ringReadFromFile(self, fileName):
    f = open(fileName, "r")
    a = []
    for line in f:
      if (line[0] != '[') and (line[0] != ']'):
        x = int(line)
        a.append(cint(x))
    return a

  def readFromPrivateInput(self, partyNum):
    res = []
    n = self.n
    for i in range(0, n):
      res.append(sint.get_raw_input_from(partyNum))
    return res


class LWE(object):

  # In order for decryption to work,
  #   N and m=2^lgM must be chosen appropriately.
  # Namely, if you wish to do t ciphertext additions
  #   and p is the size of the SCALE-MAMBA field, then need:
  #   t*2*N^2 < p / (2*m)
  def __init__(self, r, N, lgM):
    self.r = r  # Ring used
    self.N = N  # Half-width of binomial distributions
    # m = Modulus of ciphertext additions
    # Require p = 1 (mod 2m), and m to be a power of 2
    self.lgM = lgM
    self.m = 2 ** lgM
    return

  # Returns [a, b, s]
  # (a, b) is the public key, s is the secret key
  def key_gen(self):
    r = self.r
    N = self.N
    a = r.ringRandClear()
    s = r.ringBinom(N)
    e = r.ringBinom(N)
    b = r.reveal(r.ringAdd(r.ringMulFast(a, s), e))

    res = [a, b, s]
    return res

  # z is plaintext as bit-array
  # returns ciphertext [u, v]
  def enc(self, a, b, z):
    r = self.r
    N = self.N
    m = self.m
    e0 = r.ringBinom(N)
    e1 = r.ringBinom(N)
    e2 = r.ringBinom(N)

    # u = a*e0 + e1 (mod q)
    u = r.ringMulFast(a, e0)
    u = r.ringAdd(u, e1)
 
    # v = b*e0 + e2 + round(p/m)z (mod p) 
    mthP = cint(-1)/cint(m)
    zMthP = []

    for i in range(0, len(z)):
      zMthP.append(z[i] * mthP)
  
    v = r.ringMulFast(b, e0)
    v = r.ringAdd(v, e2)
    v = r.ringAdd(v, zMthP)

    res = [r.reveal(u), r.reveal(v)]
    return res


  def dec(self, u, v, s):
    r = self.r
    lgM = self.lgM
    m = 1 << lgM
    clearM = cint(m)
    zNoisy = r.ringSub(v, r.ringMulFast(u, s))
    halfMthP = cint(-1)/(2*m)
    z = []
    for i in range(0, len(zNoisy)):
      zRangeI = zNoisy[i] + halfMthP
      zNotchesI = zRangeI * clearM
      z.append(m - 1 - ((zNotchesI - 1) % m))

    return z


