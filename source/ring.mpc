class Ring(object):

  # Defines parameters for the ring Z/pZ/<X^n + 1>
  # i.e. A ring of polynomials where coefficients are
  #   in Z/pZ, and where polynomial multiplication is 
  #   reduced over X^n+1
  # p is the prime modulus natively used by SCALE-MAMBA
  # Require also that p = 1 (mod 2n)
  # n = 2^nBitsN
  # w is a 2nth primitive root of unity
  # All are public (non-secret) values
  def __init__(self, nBitsN, w):
    self.n = 1 << nBitsN
    self.nBitsN = nBitsN
    self.w = w
    return

  # Return a random element in [0, p)
  def randElem(self):
    return sint.get_random_triple()[0]

  # Return a random cint in [0, p)
  def randElemClear(self):
    return self.randElem().reveal()

  # Returns 0 or 1 each with chance 0.5
  def randBit(self):
    b = sint.get_random_int(1)
    return b

  # Selects r from (X~B(2n, 0.5) - n) mod p
  # i.e. should be centered at 0
  def modBinom(self, n):
    r = sint(0)
    for i in range(0, 2*n):
      r = r + self.randBit()
    return r - n


  # RING OPERATIONS
  # These operations are performed in a ring Z/pZ/<x^n + 1>
  # Here p is the modulus used by SCALE-MAMBA
  # It is assumed that n = len(a) = len(b).

  # Ring addition (i.e. pointwise vector addition mod p)
  def ringAdd(self, a, b):
    res = sint.Array(self.n)
    @for_range(self.n)
    def range_body(i):
      res[i] = a[i] + b[i]
    return res

  # Ring subtraction (i.e. pointwise vector subtraction mod p)
  def ringSub(self, a, b):
    res = sint.Array(self.n)
    @for_range(self.n)
    def range_body(i):
      res[i] = a[i] - b[i]
    return res

  # Ring multiplication (i.e. convolution)
  # Polynomials are represented with lowest powers first
  #   e.g. (1 + 2x + 3x^2) is represented as [1, 2, 3]
  # Reduce polynomial modulo x^(len(a)) + 1
  def ringMul(self, a, b):
    n = self.n
    conv = sint.Array(2*n)
    @for_range(2*n)
    def range_body_zero(i):
      conv[i] = sint(0)
    
    @for_range(n**2)
    def range_body_mul(i):
      j = i % n
      k = i / n
      conv[j+k] = conv[j+k] + ( a[j] * b[k] )

    res = sint.Array(n)
    @for_range(n-1)
    def range_body_wrap(i):
      res[i] = conv[i] - conv[i + n]
    
    res[n-1] = conv[n-1]
    return res

  # Fast Ring multiplication
  # From Bernstein, Daniel. "Fast multiplication and its applications." 
  # See https://cr.yp.to/papers.html#multapps
  # a, b: operands (elements of Z/pZ/<X^n + 1>
  # n : length of polynomials
  # For this to work, need len(a) = len(b) = n = 2^nBitsN
  # Note that this uses operations NATIVELY in the SCALE-MAMBA field.
  # Let p be the modulus used by SCALE-MAMBA
  # We require: p = 1 (mod 2n), w^n = -1 (mod p)
  def ringMulFast(self, a, b):
    n = self.n
    nBitsN = self.nBitsN
    nProd = self.ringMulFastRec(a, b, n, nBitsN-1, n/2)  
    res = sint.Array(n)
    res = []
    for i in range(0, n):
      res.append(nProd[i] / n)
    return res 
 
  # Return a * b
  # n = 2^nBitsN = len(a) = len(b)
  def ringMulFastRec(self, a, b, n, nBitsN, wExp): 
    res = []
    if n == 1:
      res.append(a[0] * b[0])
      return res
    
    c = self.w ** (wExp)
 
    aSplitAdd = []
    aSplitSub = []
    for i in range(0, n/2):
      t = a[i + n/2] * c
      aSplitAdd.append(a[i] + t)
      aSplitSub.append(a[i] - t)

    bSplitAdd = []
    bSplitSub = []
    for i in range(0, n/2):
      t = b[i + n/2] * c
      bSplitAdd.append(b[i] + t)
      bSplitSub.append(b[i] - t)

    resAdd = self.ringMulFastRec(aSplitAdd, bSplitAdd, n/2, nBitsN - 1, wExp/2)
    resSub = self.ringMulFastRec(aSplitSub, bSplitSub, n/2, nBitsN - 1, wExp/2 + self.n/2)

    for i in range(0, n/2):
      t = resAdd[i] + resSub[i]
      res.append(t)
    for i in range(0, n/2):
      t = resAdd[i] - resSub[i]
      res.append(t/c)
     
    return res

  # Returns 0:
  def zero(self):
    n = self.n
    zero = sint.Array(n)

    @for_range(n)
    def range_body(i):
      zero[i] = sint(0)

    return zero

  # Random ring element
  # Returns a vector of length n 
  # Each item is chosen uniformally at random from [0, p)
  # Assumes n is even
  def ringRand(self):
    n = self.n
    res = sint.Array(n)
    @for_range(n/2)
    def range_body(i):
      r = sint.get_random_triple()
      res[2*i] = r[0]
      res[2*i+1] = r[1]   # r[0] and r[1] are random and independent
    return res

  # Assumes n is even
  def ringRandClear(self):
    rand = self.ringRand()
    res = self.reveal(rand)
    return res

  # Returns a vector of length n 
  # Each item is chosen independently at random from (B(2N, 0.5) - N) mod p
  def ringBinom(self, N):
    n = self.n
    res = sint.Array(n)
    @for_range(n)
    def range_body(i):
      res[i] = self.modBinom(N)
    return res

  def ringRevealPrettyPrint(self, a):
    print_ln("[ ")
    for i in range(0, len(a)):
      print_ln("%s ", a[i].reveal())
    print_ln("]")
    return

  def reveal(self, a):
    n = self.n
    aClear = cint.Array(n)
    @for_range(n)
    def range_body(i):
      aClear[i] = a[i].reveal()
    return aClear

  # a is a ring element
  def ringRevealToParty(self, a, partyNum):
    for i in range(0, len(a)):
      a[i].reveal_to(partyNum)


  def ringReadFromFile(self, fileName):
    f = open(fileName, "r")
    a = []
    for line in f:
      if (line[0] != '[') and (line[0] != ']'):
        x = int(line)
        a.append(cint(x))
    return a

  def readFromPrivateInput(self, partyNum):
    res = []
    n = self.n
    for i in range(0, n):
      res.append(sint.get_raw_input_from(partyNum))
    return res

